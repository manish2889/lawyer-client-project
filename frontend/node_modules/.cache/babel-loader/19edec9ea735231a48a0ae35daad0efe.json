{"ast":null,"code":"import { compute as t } from \"compute-scroll-into-view\";\nconst o = t => !1 === t ? {\n  block: \"end\",\n  inline: \"nearest\"\n} : (t => t === Object(t) && 0 !== Object.keys(t).length)(t) ? t : {\n  block: \"start\",\n  inline: \"nearest\"\n};\nfunction e(e, r) {\n  if (!e.isConnected || !(t => {\n    let o = t;\n    for (; o && o.parentNode;) {\n      if (o.parentNode === document) return !0;\n      o = o.parentNode instanceof ShadowRoot ? o.parentNode.host : o.parentNode;\n    }\n    return !1;\n  })(e)) return;\n  const n = (t => {\n    const o = window.getComputedStyle(t);\n    return {\n      top: parseFloat(o.scrollMarginTop) || 0,\n      right: parseFloat(o.scrollMarginRight) || 0,\n      bottom: parseFloat(o.scrollMarginBottom) || 0,\n      left: parseFloat(o.scrollMarginLeft) || 0\n    };\n  })(e);\n  if ((t => \"object\" == typeof t && \"function\" == typeof t.behavior)(r)) return r.behavior(t(e, r));\n  const l = \"boolean\" == typeof r || null == r ? void 0 : r.behavior;\n  for (const {\n    el: a,\n    top: i,\n    left: s\n  } of t(e, o(r))) {\n    const t = i - n.top + n.bottom,\n      o = s - n.left + n.right;\n    a.scroll({\n      top: t,\n      left: o,\n      behavior: l\n    });\n  }\n}\nexport { e as default };","map":{"version":3,"sources":["../src/index.ts"],"names":["options","Object","keys","length","behavior","getOptions","block","inline","target","window","getComputedStyle","top","parseFloat","computedStyle","scrollMarginTop","right","scrollMarginRight","bottom","scrollMarginBottom","left","scrollMarginLeft","element","currentElement","parentNode","document","ShadowRoot","host","scrollIntoView","isConnected","compute","el","adjustedTop","margins","adjustedLeft","scroll"],"mappings":";AAgDA,MAUMK,CAAAA,GAAcL,CAAAA,IAAAA,CAEF,CAAA,KAAZA,CAAAA,GACK;EAAEM,KAAAA,EAAO,KAAA;EAAOC,MAAAA,EAAQ;AAAA,CAAA,GAZjCP,CAAAA,CAAAA,IAEAA,CAAAA,KAAYC,MAAAA,CAAOD,CAAAA,CAAAA,IAA4C,CAAA,KAAhCC,MAAAA,CAAOC,IAAAA,CAAKF,CAAAA,CAAAA,CAASG,MAAAA,EAavBH,CAAAA,CAAAA,GAEpBA,CAAAA,GAIF;EAAEM,KAAAA,EAAO,OAAA;EAASC,MAAAA,EAAQ;AAAA,CAAA;AA4DnC,SAASoB,CAAAA,CACPnB,CAAAA,EACAR,CAAAA,EAAAA;EAGA,IAAA,CAAKQ,CAAAA,CAAOoB,WAAAA,IAAAA,CAjDQP,CAAAA,CAAAA,IAAAA;IACpB,IAAIC,CAAAA,GAAiBD,CAAAA;IACd,OAAA,CAAA,IAAkBC,CAAAA,CAAeC,UAAAA,GAAY;MAC9C,IAAA,CAAA,CAAeA,UAAAA,KAAeC,QAAAA,EACzB,OAAA,CAAA,CAAA;MAEPF,CAAAA,GADSA,CAAAA,CAAeC,UAAAA,YAAsBE,UAAAA,GAC5BH,CAAAA,CAAeC,UAAAA,CAA0BG,IAAAA,GAE1CJ,CAAAA,CAAeC,UAEpC;IAAA;IACO,OAAA,CAAA,CAAA;EAAA,CAAA,EAsCkCf,CAAAA,CAAAA,EACvC;EAGI,MAAA,CAAA,GAlEkBA,CAAAA,CAAAA,IAAAA;IAClB,MAAA,CAAA,GAAgBC,MAAAA,CAAOC,gBAAAA,CAAiBF,CAAAA,CAAAA;IACvC,OAAA;MACLG,GAAAA,EAAKC,UAAAA,CAAWC,CAAAA,CAAcC,eAAAA,CAAAA,IAAoB,CAAA;MAClDC,KAAAA,EAAOH,UAAAA,CAAWC,CAAAA,CAAcG,iBAAAA,CAAAA,IAAsB,CAAA;MACtDC,MAAAA,EAAQL,UAAAA,CAAWC,CAAAA,CAAcK,kBAAAA,CAAAA,IAAuB,CAAA;MACxDC,IAAAA,EAAMP,UAAAA,CAAWC,CAAAA,CAAcO,gBAAAA,CAAAA,IAAqB;IAAA,CACtD;EAAA,CAAA,EA2DiCZ,CAAAA,CAAAA;EAE7B,IAvFJR,CAAAA,CAAAA,IAEmB,QAAA,IAAA,OAAZA,CAAAA,IAAmD,UAAA,IAAA,OAArBA,CAAAA,CAAQI,QAAAA,EAqFfJ,CAAAA,CAAAA,EAC5B,OAAOA,CAAAA,CAAQI,QAAAA,CAASyB,CAAAA,CAAQrB,CAAAA,EAAQR,CAAAA,CAAAA,CAAAA;EAG1C,MAAMI,CAAAA,GAA8B,SAAA,IAAA,OAAZJ,CAAAA,IAA6C,IAAA,IAATA,CAAAA,GAAAA,KAAZ,CAAA,GAAqB,CAAA,CAAA,QAAA;EAE1D,KAAA,MAAA;IAAA,EAAA,EAAE8B,CAAAA;IAAInB,GAAAA,EAAAA,CAAAA;IAAAA,IAAAA,EAAKQ;EAAAA,CAAAA,IAAUU,CAAAA,CAAQrB,CAAAA,EAAQH,CAAAA,CAAWL,CAAAA,CAAAA,CAAAA,EAAW;IACpE,MAAM+B,CAAAA,GAAcpB,CAAAA,GAAMqB,CAAAA,CAAQrB,GAAAA,GAAMqB,CAAAA,CAAQf,MAAAA;MAC1CgB,CAAAA,GAAed,CAAAA,GAAOa,CAAAA,CAAQb,IAAAA,GAAOa,CAAAA,CAAQjB,KAAAA;IACnDe,CAAAA,CAAGI,MAAAA,CAAO;MAAEvB,GAAAA,EAAKoB,CAAAA;MAAaZ,IAAAA,EAAMc,CAAAA;MAAc7B,QAAAA,EAAAA;IAAAA,CAAAA,CACpD;EAAA;AACF;AAAA,SAAA,CAAA,IAAA,OAAA","sourcesContent":["import { compute } from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/**\n * Only scrolls if the `node` is partially out of view:\n * ```ts\n * scrollIntoView(node, { scrollMode: 'if-needed' })\n * ```\n * Skips scrolling `overflow: hidden` elements:\n * ```ts\n * scrollIntoView(node, { skipOverflowHiddenElements: true })\n * ```\n * When scrolling is needed do the least and smoothest scrolling possible:\n * ```ts\n * scrollIntoView(node, {\n *   behavior: 'smooth',\n *   scrollMode: 'if-needed',\n *   block: 'nearest',\n *   inline: 'nearest',\n * })\n * ```\n * @public\n */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nconst isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nconst isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nconst getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n// Determine if the element is part of the document (including shadow dom)\n// Derived from code of Andy Desmarais\n// https://terodox.tech/how-to-tell-if-an-element-is-in-the-dom-including-the-shadow-dom/\nconst isInDocument = (element: Node) => {\n  let currentElement = element\n  while (currentElement && currentElement.parentNode) {\n    if (currentElement.parentNode === document) {\n      return true\n    } else if (currentElement.parentNode instanceof ShadowRoot) {\n      currentElement = (currentElement.parentNode as ShadowRoot).host\n    } else {\n      currentElement = currentElement.parentNode\n    }\n  }\n  return false\n}\n\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n * @public\n */\nfunction scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n *\n * You can set the expected return type for `behavior: Function`:\n * ```ts\n * await scrollIntoView<Promise<boolean[]>>(node, {\n *   behavior: async actions => {\n *     return Promise.all(actions.map(\n *       // animate() resolves to `true` if anything was animated, `false` if the element already were in the end state\n *       ({ el, left, top }) => animate(el, {scroll: {left, top}})\n *     ))\n *   }\n * })\n * ```\n * @public\n */\nfunction scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\nfunction scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  if (!target.isConnected || !isInDocument(target)) {\n    return\n  }\n\n  const margins = getScrollMargins(target)\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(compute(target, options))\n  }\n\n  const behavior = typeof options === 'boolean' ? undefined : options?.behavior\n\n  for (const { el, top, left } of compute(target, getOptions(options))) {\n    const adjustedTop = top - margins.top + margins.bottom\n    const adjustedLeft = left - margins.left + margins.right\n    el.scroll({ top: adjustedTop, left: adjustedLeft, behavior })\n  }\n}\n\nexport default scrollIntoView\n"]},"metadata":{},"sourceType":"module"}